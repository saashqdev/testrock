import { redirect } from "next/navigation";
import { getServerTranslations } from "@/i18n/server";
import { Metadata } from "next";
import { EntityViewsWithTenantAndUserDto } from "@/db/models/entityBuilder/EntityViewsModel";
import { EntityWithDetailsDto } from "@/db/models/entityBuilder/EntitiesModel";
import { verifyUserHasPermission } from "@/lib/helpers/server/PermissionsService";
import { FilterablePropertyDto } from "@/lib/dtos/data/FilterablePropertyDto";
import { getFiltersFromCurrentUrl, getPaginationFromCurrentUrl } from "@/lib/helpers/RowPaginationHelper";
import { PaginationDto } from "@/lib/dtos/data/PaginationDto";
import { IServerComponentsProps } from "@/lib/dtos/ServerComponentsProps";
import { db } from "@/db";
import EntityViewsClient from "./component";

export async function generateMetadata(): Promise<Metadata> {
  const { t } = await getServerTranslations();
  return {
    title: `${t("models.view.plural")} | ${process.env.APP_NAME}`,
  };
}

type LoaderData = {
  items: EntityViewsWithTenantAndUserDto[];
  pagination: PaginationDto;
  filterableProperties: FilterablePropertyDto[];
  entities: EntityWithDetailsDto[];
};

async function getData(props: IServerComponentsProps): Promise<LoaderData> {
  const searchParams = await props.searchParams;
  const { t } = await getServerTranslations();
  await verifyUserHasPermission("admin.entities.view");

  let type = searchParams?.type as string | undefined;
  if (type && ["default", "tenant", "user", "system"].includes(type) === false) {
    throw redirect("/admin/entities/views/all");
  }

  // Convert searchParams to URLSearchParams for pagination helper
  const urlSearchParams = new URLSearchParams();
  if (searchParams) {
    Object.entries(searchParams).forEach(([key, value]) => {
      if (value) {
        if (Array.isArray(value)) {
          value.forEach((v) => urlSearchParams.append(key, v));
        } else {
          urlSearchParams.append(key, value);
        }
      }
    });
  }
  const pagination = getPaginationFromCurrentUrl(urlSearchParams);

  const filterableProperties: FilterablePropertyDto[] = [
    {
      name: "entityId",
      title: t("models.entity.object"),
      options: (await db.entities.getAllEntitiesSimple({})).map((item) => {
        return {
          value: item.id,
          name: `${t(item.title)} (${item.name})`,
        };
      }),
    },
    {
      name: "tenantId",
      title: t("models.tenant.object"),
      options: (await db.tenants.adminGetAllTenantsIdsAndNames()).map((item) => {
        return {
          value: item.id,
          name: item.name,
        };
      }),
    },
    {
      name: "userId",
      title: t("models.user.object"),
      options: (await db.users.adminGetAllUsersNames()).map((item) => {
        return {
          value: item.id,
          name: item.email,
        };
      }),
    },
  ];

  // Create a mock Request object for the filter helper
  const mockRequest = props.request || (searchParams ? new Request(`http://localhost?${urlSearchParams.toString()}`) : undefined);
  const filters = getFiltersFromCurrentUrl(mockRequest, filterableProperties);

  const { items, total } = await db.entityViews.getAllEntityViews({
    type: type ?? undefined,
    pagination: { pageSize: pagination.pageSize, page: pagination.page },
    filters,
  });

  // Get full entities data (needed for the edit form)
  // Include system entities (isAutogenerated: true) for admin area
  const allEntities = await db.entities.getAllEntities(null, true);
  const activeEntities = allEntities.filter((e) => e.active);

  const data: LoaderData = {
    items,
    pagination: {
      page: pagination.page,
      pageSize: pagination.pageSize,
      totalItems: total,
      totalPages: Math.ceil(total / pagination.pageSize),
    },
    filterableProperties,
    entities: activeEntities,
  };
  return data;
}

export default async function EntityViewsPage(props: IServerComponentsProps) {
  const data = await getData(props);

  return <EntityViewsClient {...data} />;
}
