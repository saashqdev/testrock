import { MetaTagsDto } from "@/lib/dtos/seo/MetaTagsDto";
import { EntitiesApi } from "@/utils/api/server/EntitiesApi";
import { RowsApi } from "@/utils/api/server/RowsApi";
import UrlUtils from "@/utils/app/UrlUtils";
import EntityHelper from "@/lib/helpers/EntityHelper";
import { getEntityPermission } from "@/lib/helpers/PermissionsHelper";
import { verifyUserHasPermission } from "@/lib/helpers/server/PermissionsService";
import RowHelper from "@/lib/helpers/RowHelper";
import { getUserInfo } from "@/lib/services/session.server";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import { createMetrics } from "@/modules/metrics/services/server/MetricTracker";
import FormulaService from "@/modules/formulas/services/server/FormulaService";
import { EntityWithDetailsDto } from "@/db/models/entityBuilder/EntitiesModel";
import { RowWithDetailsDto } from "@/db/models/entityBuilder/RowsModel";
import { IServerComponentsProps } from "@/lib/dtos/ServerComponentsProps";
import { db } from "@/db";

export namespace Rows_New {
  export type LoaderData = {
    meta: MetaTagsDto;
    entityData: EntitiesApi.GetEntityData;
    routes: EntitiesApi.Routes;
    allEntities: EntityWithDetailsDto[];
    relationshipRows: RowsApi.GetRelationshipRowsData;
  };
  export const loader = async (props: IServerComponentsProps) => {
    const params = (await props.params) || {};
    const request = props.request!;    
    const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_New] ${params.entity}`);
    const { t, userId, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params: props.params });
    if (!entity.isAutogenerated || entity.type === "system") {
      return new Response(null, { 
        status: 404, 
        headers: { 
          Location: tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404",
          ...getServerTimingHeader() 
        } 
      });
    }
    const entityData = await time(
      EntitiesApi.get({
        entity,
        tenantId,
        userId,
      }),
      "EntitiesApi"
    );
    await time(verifyUserHasPermission(getEntityPermission(entity, "create"), tenantId), "verifyUserHasPermission");
    const data: LoaderData = {
      meta: [{ title: `${t("shared.create")} ${t(entity.title)} | ${process.env.APP_NAME}` }],
      entityData,
      routes: EntitiesApi.getNoCodeRoutes({ request, params }),
      allEntities: await time(db.entities.getAllEntities(null, true), "getAllEntities"),
      relationshipRows: await time(RowsApi.getRelationshipRows({ entity, tenantId, userId }), "RowsApi.getRelationshipRows"),
    };
    return Response.json(data, { headers: getServerTimingHeader() });
  };

  export type ActionData = {
    saveAndAdd?: boolean;
    newRow?: RowWithDetailsDto;
    error?: string;
  };
  export const action = async (props: IServerComponentsProps) => {
    const params = (await props.params) || {};
    const request = props.request!;    
    const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_New] ${params.entity}`);
    const { t, userId, tenantId, entity, form } = await RowsRequestUtils.getAction({ request, params: props.params });
    const action = form.get("action");
    if (action === "create") {
      try {
        await time(verifyUserHasPermission(getEntityPermission(entity, "create"), tenantId), "verifyUserHasPermission");
        const rowValues = RowHelper.getRowPropertiesFromForm({ t: t, entity, form });
        const newRow = await time(
          RowsApi.create({
            entity,
            tenantId,
            userId: (await getUserInfo()).userId,
            rowValues,
            request,
          }),
          "RowsApi.create"
        );
        await time(
          FormulaService.trigger({ trigger: "AFTER_CREATED", rows: [newRow], entity: entity, session: { tenantId, userId }, t }),
          "FormulaService.trigger.AFTER_CREATED"
        );
        const onCreatedRedirect = form.get("onCreatedRedirect");
        if (onCreatedRedirect) {
          if (onCreatedRedirect === "addAnother") {
            return Response.json({ saveAndAdd: true, newRow, headers: getServerTimingHeader() });
          }
          const routes = EntityHelper.getRoutes({ routes: EntitiesApi.getNoCodeRoutes({ request, params }), entity, item: newRow });
          if (routes) {
            if (!entity.onCreated || entity.onCreated === "redirectToOverview") {
              return new Response(null, { 
                status: 302, 
                headers: { 
                  Location: routes?.overview ?? "",
                  ...getServerTimingHeader() 
                } 
              });
            } else if (entity.onCreated === "redirectToEdit") {
              return new Response(null, { 
                status: 302, 
                headers: { 
                  Location: routes?.edit ?? "",
                  ...getServerTimingHeader() 
                } 
              });
            } else if (entity.onCreated === "redirectToList") {
              return new Response(null, { 
                status: 302, 
                headers: { 
                  Location: routes?.list ?? "",
                  ...getServerTimingHeader() 
                } 
              });
            } else if (entity.onCreated === "redirectToNew") {
              return Response.json({ newRow, replace: true }, { headers: getServerTimingHeader() });
            } else if (params.group && entity.onCreated === "redirectToGroup") {
              return new Response(null, { 
                status: 302, 
                headers: { 
                  Location: routes?.group ?? "",
                  ...getServerTimingHeader() 
                } 
              });
            }
          }
        }
        const redirectTo = form.get("redirect")?.toString() || new URL(request.url).searchParams.get("redirect")?.toString();
        if (redirectTo) {
          return new Response(null, { 
            status: 302, 
            headers: { 
              Location: redirectTo,
              ...getServerTimingHeader() 
            } 
          });
        }
        return Response.json({ newRow, headers: getServerTimingHeader() });
      } catch (error: any) {
        return Response.json({ error: error.message }, { status: 400, headers: getServerTimingHeader() });
      }
    } else {
      return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
    }
  };
}
