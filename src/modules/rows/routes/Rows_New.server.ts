import { MetaTagsDto } from "@/lib/dtos/seo/MetaTagsDto";
import { GetEntityData, Routes, get, getNoCodeRoutes } from "@/utils/api/server/EntitiesApi";
import { GetRelationshipRowsData, getRelationshipRows, create } from "@/utils/api/server/RowsApi";
import UrlUtils from "@/utils/app/UrlUtils";
import EntityHelper from "@/lib/helpers/EntityHelper";
import { getEntityPermission } from "@/lib/helpers/PermissionsHelper";
import { verifyUserHasPermission } from "@/lib/helpers/server/PermissionsService";
import RowHelper from "@/lib/helpers/RowHelper";
import { getUserInfo } from "@/lib/services/session.server";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import { createMetrics } from "@/modules/metrics/services/server/MetricTracker";
import FormulaService from "@/modules/formulas/services/server/FormulaService";
import { EntityWithDetailsDto } from "@/db/models/entityBuilder/EntitiesModel";
import { RowWithDetailsDto } from "@/db/models/entityBuilder/RowsModel";
import { IServerComponentsProps } from "@/lib/dtos/ServerComponentsProps";
import { db } from "@/db";
import { headers } from "next/headers";

export type LoaderData = {
  meta: MetaTagsDto;
  entityData: GetEntityData;
  routes: Routes;
  allEntities: EntityWithDetailsDto[];
  relationshipRows: GetRelationshipRowsData;
};
export const loader = async (props: IServerComponentsProps) => {
  const params = (await props.params) || {};
  const headersList = await headers();
  const request = new Request("http://localhost", {
    headers: headersList,
  });
  const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_New] ${params.entity}`);
  const { t, userId, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params: props.params });
  if (!entity.isAutogenerated || entity.type === "system") {
    return new Response(null, { 
      status: 404, 
      headers: { 
        Location: tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404",
        ...getServerTimingHeader() 
      } 
    });
  }
  const entityData = await time(
    get({
      entity,
      tenantId,
      userId,
    }),
    "EntitiesApi"
  );
  await time(verifyUserHasPermission(getEntityPermission(entity, "create"), tenantId), "verifyUserHasPermission");
  const data: LoaderData = {
    meta: [{ title: `${t("shared.create")} ${t(entity.title)} | ${process.env.APP_NAME}` }],
    entityData,
    routes: getNoCodeRoutes({ request, params }),
    allEntities: await time(db.entities.getAllEntities(null, true), "getAllEntities"),
    relationshipRows: await time(getRelationshipRows({ entity, tenantId, userId }), "getRelationshipRows"),
  };
  return Response.json(data, { headers: getServerTimingHeader() });
};

export type ActionData = {
  saveAndAdd?: boolean;
  newRow?: RowWithDetailsDto;
  error?: string;
};
export const action = async (props: IServerComponentsProps) => {
  const params = (await props.params) || {};
  const headersList = await headers();
  const request = new Request("http://localhost", {
    headers: headersList,
  });
  const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_New] ${params.entity}`);
  const { t, userId, tenantId, entity, form } = await RowsRequestUtils.getAction({ request, params: props.params });
  const action = form.get("action");
  if (action === "create") {
    try {
      await time(verifyUserHasPermission(getEntityPermission(entity, "create"), tenantId), "verifyUserHasPermission");
      const rowValues = RowHelper.getRowPropertiesFromForm({ t: t, entity, form });
      const newRow = await time(
        create({
          entity,
          tenantId,
          userId: (await getUserInfo()).userId,
          rowValues,
          request,
        }),
        "create"
      );
      await time(
        FormulaService.trigger({ trigger: "AFTER_CREATED", rows: [newRow], entity: entity, session: { tenantId, userId }, t }),
        "FormulaService.trigger.AFTER_CREATED"
      );
      const onCreatedRedirect = form.get("onCreatedRedirect");
      if (onCreatedRedirect) {
        if (onCreatedRedirect === "addAnother") {
          return Response.json({ saveAndAdd: true, newRow, headers: getServerTimingHeader() });
        }
        const routes = EntityHelper.getRoutes({ routes: getNoCodeRoutes({ request, params }), entity, item: newRow });
        if (routes) {
          if (!entity.onCreated || entity.onCreated === "redirectToOverview") {
            return new Response(null, { 
              status: 302, 
              headers: { 
                Location: routes?.overview ?? "",
                ...getServerTimingHeader() 
              } 
            });
          } else if (entity.onCreated === "redirectToEdit") {
            return new Response(null, { 
              status: 302, 
              headers: { 
                Location: routes?.edit ?? "",
                ...getServerTimingHeader() 
              } 
            });
          } else if (entity.onCreated === "redirectToList") {
            return new Response(null, { 
              status: 302, 
              headers: { 
                Location: routes?.list ?? "",
                ...getServerTimingHeader() 
              } 
            });
          } else if (entity.onCreated === "redirectToNew") {
            return Response.json({ newRow, replace: true }, { headers: getServerTimingHeader() });
          } else if (params.group && entity.onCreated === "redirectToGroup") {
            return new Response(null, { 
              status: 302, 
              headers: { 
                Location: routes?.group ?? "",
                ...getServerTimingHeader() 
              } 
            });
          }
        }
      }
      const redirectTo = form.get("redirect")?.toString() || new URL(request.url).searchParams.get("redirect")?.toString();
      if (redirectTo) {
        return new Response(null, { 
          status: 302, 
          headers: { 
            Location: redirectTo,
            ...getServerTimingHeader() 
          } 
        });
      }
      return Response.json({ newRow, headers: getServerTimingHeader() });
    } catch (error: any) {
      return Response.json({ error: error.message }, { status: 400, headers: getServerTimingHeader() });
    }
  } else {
    return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
  }
};

