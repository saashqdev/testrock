import { redirect } from "next/navigation";
import { MetaTagsDto } from "@/lib/dtos/seo/MetaTagsDto";
import NotificationService from "@/modules/notifications/services/server/NotificationService";
import { Routes, getNoCodeRoutes } from "@/utils/api/server/EntitiesApi";
import { create } from "@/utils/api/server/RowCommentsApi";
import { GetRowData, get, GetRelationshipRowsData, getRelationshipRows, update, del } from "@/utils/api/server/RowsApi";
import UrlUtils from "@/utils/app/UrlUtils";
import EntityHelper from "@/lib/helpers/EntityHelper";
import { getEntityPermission } from "@/lib/helpers/PermissionsHelper";
import { verifyUserHasPermission } from "@/lib/helpers/server/PermissionsService";
import RowHelper from "@/lib/helpers/RowHelper";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import { createMetrics } from "@/modules/metrics/services/server/MetricTracker";
import FormulaService from "@/modules/formulas/services/server/FormulaService";
import PromptBuilderService from "@/modules/promptBuilder/services/server/PromptBuilderService";
import { PromptExecutionResultDto } from "@/modules/promptBuilder/dtos/PromptExecutionResultDto";
import EventsService from "@/modules/events/services/server/EventsService";
import { RowTasksCreatedDto } from "@/modules/events/dtos/RowTasksCreatedDto";
import { RowTasksUpdatedDto } from "@/modules/events/dtos/RowTasksUpdatedDto";
import { RowTasksDeletedDto } from "@/modules/events/dtos/RowTasksDeletedDto";
import { RowCommentsCreatedDto } from "@/modules/events/dtos/RowCommentsCreatedDto";
import { RowCommentsReactedDto } from "@/modules/events/dtos/RowCommentsReactedDto";
import { RowCommentsDeletedDto } from "@/modules/events/dtos/RowCommentsDeletedDto";
import { IServerComponentsProps } from "@/lib/dtos/ServerComponentsProps";
import { db } from "@/db";
import { headers } from "next/headers";

export type LoaderData = {
  meta: MetaTagsDto;
  rowData: GetRowData;
  routes: Routes;
  relationshipRows: GetRelationshipRowsData;
};
export const loader = async (props: IServerComponentsProps) => {
  const params = (await props.params) || {};
  const headersList = await headers();
  const request = new Request("http://localhost", {
    headers: headersList,
  });    
  const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_Overview] ${params.entity}`);
  const { t, userId, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params: props.params });
  await time(verifyUserHasPermission(getEntityPermission(entity, "read"), tenantId), "verifyUserHasPermission");
  if (!entity.isAutogenerated || entity.type === "system") {
    return new Response(null, {
      status: 404,
      headers: {
        Location: tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404",
        ...getServerTimingHeader()
      }
    });
  }
  const rowData = await time(
    get(params.id!, {
      entity,
      tenantId,
      userId,
    }),
    "get"
  );
  await time(
    FormulaService.trigger({ trigger: "BEFORE_VIEWED", rows: [rowData.item], entity: rowData.entity, session: { tenantId, userId }, t }),
    "FormulaService.trigger.BEFORE_VIEWED"
  );
  const data: LoaderData = {
    meta: [{ title: `${t(RowHelper.getTextDescription({ entity, item: rowData.item, t }))} | ${t(entity.titlePlural)} | ${process.env.APP_NAME}` }],
    rowData,
    routes: getNoCodeRoutes({ request, params }),
    relationshipRows: await time(getRelationshipRows({ entity, tenantId, userId }), "getRelationshipRows"),
  };
  return Response.json(data, { headers: getServerTimingHeader() });
};

export type ActionData = {
  updatedRow?: GetRowData;
  success?: string;
  error?: string;
  promptFlowExecutionResult?: PromptExecutionResultDto | null;
};
export const action = async (props: IServerComponentsProps) => {
  const params = (await props.params) || {};
  const headersList = await headers();
  const request = new Request("http://localhost", {
    headers: headersList,
  });
  const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_Overview] ${params.entity}`);
  const { t, userId, tenantId, entity, form } = await RowsRequestUtils.getAction({ request, params: props.params });
  const action = form.get("action")?.toString() ?? "";
  const user = await time(db.users.getUser(userId), "getUser");
  const rowData = await time(
    get(params.id!, {
      entity,
      tenantId,
      userId,
    }),
    "get"
  );
  const { item } = rowData;

  if (action === "edit") {
    try {
      const rowValues = RowHelper.getRowPropertiesFromForm({ t, entity, form, existing: item });
      await time(
        update(params.id!, {
          entity,
          tenantId,
          userId,
          rowValues,
        }),
        "update"
      );
    } catch (error: any) {
      return Response.json({ error: error.message }, { status: 400, headers: getServerTimingHeader() });
    }
    // const redirectTo = form.get("redirect")?.toString() || new URL(request.url).searchParams.get("redirect")?.toString();
    // if (redirectTo) {
    //   return redirect(redirectTo, { headers: getServerTimingHeader() });
    // }
    const updatedRow = await time(get(params.id!, { entity }), "get");
    return Response.json({ updatedRow, success: t("shared.saved") }, { headers: getServerTimingHeader() });
  } else if (action === "delete") {
    try {
      await time(verifyUserHasPermission(getEntityPermission(entity, "create"), tenantId), "verifyUserHasPermission");
      await time(
        del(params.id!, {
          entity,
          tenantId,
          userId,
        }),
        "del"
      );
      if (item.createdByUser) {
        await time(
          NotificationService.send({
            channel: "my-rows",
            to: item.createdByUser,
            notification: {
              from: { user },
              message: `${user?.email} deleted ${RowHelper.getTextDescription({ entity, item })}`,
              action: {
                title: t("shared.view"),
                url: EntityHelper.getRoutes({ routes: getNoCodeRoutes({ request, params }), entity, item })?.overview ?? "",
              },
            },
          }),
          "NotificationService.send"
        );
      }
    } catch (error: any) {
      return Response.json({ error: error.message }, { status: 400, headers: getServerTimingHeader() });
    }
    const redirectTo = form.get("redirect")?.toString() || new URL(request.url).searchParams.get("redirect")?.toString();
    if (redirectTo) {
      return new Response(null, { status: 302, headers: { Location: redirectTo, ...getServerTimingHeader() } });
    }
    const routes = getNoCodeRoutes({ request, params });
    const listRoute = EntityHelper.getRoutes({ routes, entity })?.list;
    if (listRoute) {
      return new Response(null, { status: 302, headers: { Location: listRoute, ...getServerTimingHeader() } });
    }
    return Response.json({ deleted: true }, { headers: getServerTimingHeader() });
  } else if (action === "comment") {
    let comment = form.get("comment")?.toString();
    if (!comment) {
      return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
    }
    await time(
      create(item.id, {
        comment,
        userId,
      }),
      "create"
    );
    await EventsService.create({
      request,
      event: "row.comments.created",
      tenantId,
      userId,
      data: {
        rowId: item.id,
        comment: { id: item.id, text: comment },
        user: !user ? null : { id: user.id, email: user.email },
      } satisfies RowCommentsCreatedDto,
    });
    if (item.createdByUser) {
      await time(
        NotificationService.send({
          channel: "my-rows",
          to: item.createdByUser,
          notification: {
            from: { user },
            message: `${user?.email} commented on ${RowHelper.getTextDescription({ entity, item })}`,
            action: {
              title: t("shared.view"),
              url: EntityHelper.getRoutes({ routes: getNoCodeRoutes({ request, params }), entity, item })?.overview ?? "",
            },
          },
        }),
        "NotificationService.send"
      );
    }
    return Response.json({ newComment: comment }, { headers: getServerTimingHeader() });
  } else if (action === "comment-reaction") {
    const rowCommentId = form.get("comment-id")?.toString();
    const reaction = form.get("reaction")?.toString();
    if (!rowCommentId || !reaction) {
      return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
    }
    const comment = await time(db.rowComments.getRowComment(rowCommentId), "getRowComment");
    if (comment) {
      await time(
        db.rowCommentReaction.setRowCommentReaction({
          createdByUserId: userId,
          rowCommentId,
          reaction,
        }),
        "setRowCommentReaction"
      );
      await EventsService.create({
        request,
        event: "row.comments.reacted",
        tenantId,
        userId,
        data: {
          rowId: item.id,
          comment: { id: comment.id, text: comment.value },
          reaction,
          user: !user ? null : { id: user.id, email: user.email },
        } satisfies RowCommentsReactedDto,
      });
    }
    return Response.json({ newCommentReaction: reaction }, { headers: getServerTimingHeader() });
  } else if (action === "comment-delete") {
    const rowCommentId = form.get("comment-id")?.toString() ?? "";
    const comment = await db.rowComments.getRowComment(rowCommentId);
    if (!comment) {
      return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
    }
    await time(db.rowComments.updateRowComment(comment.id, { isDeleted: true }), "updateRowComment");
    await EventsService.create({
      request,
      event: "row.comments.deleted",
      tenantId,
      userId,
      data: {
        rowId: item.id,
        comment: { id: comment.id, text: comment.value },
        user: !user ? null : { id: user.id, email: user.email },
      } satisfies RowCommentsDeletedDto,
    });
    return Response.json({ deletedComment: rowCommentId }, { headers: getServerTimingHeader() });
  } else if (action === "task-new") {
    const taskTitle = form.get("task-title")?.toString();
    if (!taskTitle) {
      return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
    }
    const task = await time(
      db.rowTasks.createRowTask({
        createdByUserId: userId,
        rowId: item.id,
        title: taskTitle,
      }),
      "createRowTask"
    );
    await EventsService.create({
      request,
      event: "row.tasks.created",
      tenantId,
      userId,
      data: {
        rowId: item.id,
        task: { id: task.id, name: task.title },
        user: !user ? null : { id: user.id, email: user.email },
      } satisfies RowTasksCreatedDto,
    });
    return Response.json({ newTask: task }, { headers: getServerTimingHeader() });
  } else if (action === "task-complete-toggle") {
    const taskId = form.get("task-id")?.toString() ?? "";
    const task = await time(db.rowTasks.getRowTask(taskId), "getRowTask");
    if (task) {
      if (task.completed) {
        await time(
          db.rowTasks.updateRowTask(taskId, {
            completed: false,
            completedAt: null,
            completedByUserId: null,
          }),
          "updateRowTask"
        );
      } else {
        await time(
          db.rowTasks.updateRowTask(taskId, {
            completed: true,
            completedAt: new Date(),
            completedByUserId: userId,
          }),
          "updateRowTask"
        );
      }
      await EventsService.create({
        request,
        event: "row.tasks.created",
        tenantId,
        userId,
        data: {
          rowId: item.id,
          old: { id: task.id, name: task.title, completedAt: task.completedAt },
          new: { id: task.id, name: task.title, completedAt: task.completed ? new Date() : null },
          user: !user ? null : { id: user.id, email: user.email },
        } satisfies RowTasksUpdatedDto,
      });
    }
    return Response.json({ completedTask: taskId }, { headers: getServerTimingHeader() });
  } else if (action === "task-delete") {
    const taskId = form.get("task-id")?.toString() ?? "";
    const task = await time(db.rowTasks.getRowTask(taskId), "getRowTask");
    if (task) {
      await time(db.rowTasks.deleteRowTask(taskId), "deleteRowTask");
      await EventsService.create({
        request,
        event: "row.tasks.deleted",
        tenantId,
        userId,
        data: {
          rowId: item.id,
          task: { id: task.id, name: task.title },
          user: !user ? null : { id: user.id, email: user.email },
        } satisfies RowTasksDeletedDto,
      });
    }
    return Response.json({ deletedTask: taskId }, { headers: getServerTimingHeader() });
  } else if (action === "run-prompt-flow") {
    try {
      const promptFlowExecutionResult = await PromptBuilderService.runFromForm({ request, params, form, tenantId, userId, time, t });
      return Response.json({ promptFlowExecutionResult }, { headers: getServerTimingHeader() });
    } catch (e: any) {
      return Response.json({ error: e.message }, { status: 400, headers: getServerTimingHeader() });
    }
  } else {
    return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
  }
};

