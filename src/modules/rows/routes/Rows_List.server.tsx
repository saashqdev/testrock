import { redirect } from "next/navigation";
import { headers } from "next/headers";
import { GetRowsData, getAll, del, changeOrder } from "@/utils/api/server/RowsApi";
import { getEntityPermission } from "@/lib/helpers/PermissionsHelper";
import { verifyUserHasPermission } from "@/lib/helpers/server/PermissionsService";
import { Routes, getNoCodeRoutes } from "@/utils/api/server/EntitiesApi";
import UrlUtils from "@/utils/app/UrlUtils";
import { createFromForm, updateFromForm } from "@/utils/api/server/EntityViewsApi";
import { MetaTagsDto } from "@/lib/dtos/seo/MetaTagsDto";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import { createMetrics } from "@/modules/metrics/services/server/MetricTracker";
import FormulaService from "@/modules/formulas/services/server/FormulaService";
import PromptBuilderService from "@/modules/promptBuilder/services/server/PromptBuilderService";
import { EntityView } from "@prisma/client";
import { PromptExecutionResultDto } from "@/modules/promptBuilder/dtos/PromptExecutionResultDto";
import { IServerComponentsProps } from "@/lib/dtos/ServerComponentsProps";
import { db } from "@/db";

export type LoaderData = {
  meta: MetaTagsDto;
  rowsData: GetRowsData;
  routes: Routes;
};
export const loader = async (props: IServerComponentsProps) => {
  const params = (await props.params) || {};
  const searchParams = (await props.searchParams) || {};
  
  // Construct request if not available (server component context)
  let request = props.request;
  if (!request) {
    const headersList = await headers();
    const url = headersList.get("x-url") || headersList.get("x-pathname") || "/";
    request = new Request(url.startsWith("http") ? url : `http://localhost${url}`);
  }
  
  const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_List] ${params.entity}`);
  const { t, userId, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params: props.params });
  await time(verifyUserHasPermission(getEntityPermission(entity, "view"), tenantId), "verifyUserHasPermission");
  if (!entity.isAutogenerated || entity.type === "system") {
    throw redirect(tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404");
  }
  
  // Convert searchParams object to URLSearchParams
  const urlSearchParams = new URLSearchParams();
  Object.entries(searchParams).forEach(([key, value]) => {
    if (value !== undefined) {
      if (Array.isArray(value)) {
        value.forEach(v => urlSearchParams.append(key, v));
      } else {
        urlSearchParams.append(key, value);
      }
    }
  });
  
  const rowsData = await time(
    getAll({
      entity,
      tenantId,
      userId,
      urlSearchParams,
      time,
    }),
    "getAll"
  );
  await time(
    FormulaService.trigger({ trigger: "BEFORE_LISTED", rows: rowsData.items, entity: rowsData.entity, session: { tenantId, userId }, t }),
    "FormulaService.trigger.BEFORE_LISTED"
  );
  const data: LoaderData = {
    meta: [{ title: `${t(entity.titlePlural)} | ${process.env.APP_NAME}` }],
    rowsData,
    routes: getNoCodeRoutes({ request, params }),
  };
  return Response.json(data, { headers: getServerTimingHeader() });
};

export type ActionData = {
  success?: string;
  error?: string;
  updatedView?: Omit<EntityView, "order"> & { order: number | null };
  rowsDeleted?: string[];
  promptFlowExecutionResult?: PromptExecutionResultDto | null;
};
export const action = async (props: IServerComponentsProps) => {
  const params = (await props.params) || {};
  const request = props.request!;    
  const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_List] ${params.entity}`);
  const { t, userId, tenantId, entity, form } = await RowsRequestUtils.getAction({ request, params: props.params });
  const action = form.get("action")?.toString() ?? "";
  if (action === "view-create") {
    try {
      const view = await time(createFromForm({ entity, form, createdByUserId: userId }), "createFromForm");
      const url = new URL(request.url);
      return new Response(null, { 
        status: 302, 
        headers: { 
          Location: url.pathname + "?v=" + view.name,
          ...getServerTimingHeader() 
        } 
      });
    } catch (e: any) {
      return Response.json({ error: e.message }, { status: 400, headers: getServerTimingHeader() });
    }
  } else if (action === "view-edit" || action === "view-delete") {
    const id = form.get("id")?.toString() ?? "";
    const item = await time(db.entityViews.getEntityView(id), "getEntityView");
    if (!item) {
      return Response.json({ error: t("shared.notFound") }, { status: 400, headers: getServerTimingHeader() });
    }
    try {
      if (action === "view-edit") {
        const updatedView = await time(updateFromForm({ entity, item, form }), "updateFromForm");
        const actionData: ActionData = {
          updatedView,
        };
        return Response.json(actionData, { headers: getServerTimingHeader() });
      } else {
        await time(db.entityViews.deleteEntityView(item.id), "deleteEntityView");
        const url = new URL(request.url);
        return new Response(null, { 
          status: 302, 
          headers: { 
            Location: url.pathname + "?v=",
            ...getServerTimingHeader() 
          } 
        });
      }
    } catch (e: any) {
      return Response.json({ error: e.message }, { status: 400, headers: getServerTimingHeader() });
    }
  } else if (["move-up", "move-down"].includes(action)) {
    const id = form.get("id")?.toString() ?? "";
    await time(
      changeOrder(id, {
        target: action === "move-up" ? "up" : "down",
      }),
      "changeOrder"
    );
    return Response.json({}, { headers: getServerTimingHeader() });
  } else if (action === "run-prompt-flow") {
    try {
      const promptFlowExecutionResult = await PromptBuilderService.runFromForm({ request, params, form, tenantId, userId, time, t });
      const actionData: ActionData = {
        promptFlowExecutionResult,
      };
      return Response.json(actionData, { headers: getServerTimingHeader() });
    } catch (e: any) {
      return Response.json({ error: e.message }, { status: 400, headers: getServerTimingHeader() });
    }
  } else if (action === "bulk-delete") {
    if (!entity.hasBulkDelete) {
      return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
    }
    const rowIds = form.getAll("rowIds[]") as string[];
    try {
      const rows = await db.rows.getRowsInIds(rowIds);
      const inexistentRows = rowIds.filter((id) => !rows.find((f) => f.id === id));
      if (inexistentRows.length > 0) {
        return Response.json({ error: t("shared.notFound") }, { status: 400, headers: getServerTimingHeader() });
      }
      const rowsDeleted: string[] = [];
      await Promise.all(
        rows.map(async (row) => {
          const deleted = await del(row.id, { entity, tenantId, userId });
          rowsDeleted.push(deleted.id);
        })
      );
      return Response.json({ success: t("shared.deleted"), rowsDeleted }, { headers: getServerTimingHeader() });
    } catch (e: any) {
      return Response.json({ error: e.message }, { status: 400, headers: getServerTimingHeader() });
    }
  } else {
    return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
  }
};

