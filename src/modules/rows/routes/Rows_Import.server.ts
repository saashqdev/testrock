import { redirect } from "next/navigation";
import { MetaTagsDto } from "@/lib/dtos/seo/MetaTagsDto";
import { Colors } from "@/lib/enums/shared/Colors";
import { create, addTag } from "@/utils/api/server/RowsApi";
import UrlUtils from "@/utils/app/UrlUtils";
import { EntityWithDetailsDto } from "@/db/models/entityBuilder/EntitiesModel";
import { RowWithDetailsDto } from "@/db/models/entityBuilder/RowsModel";
import RowHelper from "@/lib/helpers/RowHelper";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import { IServerComponentsProps } from "@/lib/dtos/ServerComponentsProps";
import { db } from "@/db";

export type LoaderData = {
  meta: MetaTagsDto;
  entity: EntityWithDetailsDto;
  allTenants: { id: string; name: string; slug: string }[];
};
export const loader = async (props: IServerComponentsProps) => {
  const params = (await props.params) || {};
  const request = props.request!;    
  const { t, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params: props.params });
  if (!entity.isAutogenerated || entity.type === "system") {
    throw redirect(tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404");
  }
  const data: LoaderData = {
    meta: [{ title: `${t("shared.import")} ${t(entity.titlePlural)} | ${process.env.APP_NAME}` }],
    entity,
    allTenants: !tenantId ? await db.tenants.adminGetAllTenantsIdsAndNames() : [],
  };
  return Response.json(data);
};

export interface ImportRow {
  properties: { name: string; value: string }[];
  row?: RowWithDetailsDto | null;
  error?: string;
}
export type ActionData = {
  rows?: ImportRow[];
  error?: string;
};
export const action = async (props: IServerComponentsProps) => {
  const params = (await props.params) || {};
  const request = props.request!;    
  const { t, userId, tenantId, entity, form } = await RowsRequestUtils.getAction({ request, params: props.params });
  const action = form.get("action");
  if (action === "import") {
    const tag = form.get("tag")?.toString() ?? "import";
    const rawRows: ImportRow[] = form.getAll("rows[]").map((f: FormDataEntryValue) => {
      return JSON.parse(f.toString());
    });
    let tenantToImport = tenantId;
    if (tenantId === null) {
      const selectedTenantId = form.get("selectedTenantId")?.toString() || "{null}";
      if (selectedTenantId === "{null}") {
        tenantToImport = null;
      } else {
        const existingTenant = await db.tenants.getTenant(selectedTenantId);
        if (!existingTenant) {
          return Response.json({ error: "Invalid tenant with ID: " + selectedTenantId }, { status: 400 });
        }
        tenantToImport = selectedTenantId;
      }
    }

    if (rawRows.length === 0) {
      return Response.json({ error: "No rows to import" }, { status: 400 });
    }
    const rows: ImportRow[] = [];
    let folio = 1;
    const maxFolio = await db.rows.getMaxRowFolio({ tenantId: tenantToImport, entityId: entity.id });
    if (maxFolio && maxFolio._max.folio !== null) {
      folio = maxFolio._max.folio + 1;
    }
    await Promise.all(
      rawRows.map(async (importRow: ImportRow, idx) => {
        try {
          // Wait for keeping folios unique, I can't think of another way to do this
          await new Promise((r) => setTimeout(r, 1500));
          const rowValues = RowHelper.getRowPropertiesFromForm({ t, entity, values: importRow.properties });
          const newRow = await create({
            entity,
            tenantId: tenantToImport,
            userId,
            rowValues,
            nextFolio: folio + idx,
            request,
          });
          if (tag) {
            await addTag({ row: newRow, tag: { value: tag, color: Colors.INDIGO } });
          }
          importRow.row = await db.rows.getRowById(newRow.id);
        } catch (e: any) {
          importRow.error = e.message?.toString();
        }
        rows.push(importRow);
      })
    );
    const data: ActionData = {
      rows,
    };
    return data;
  } else {
    return Response.json({ error: "Invalid form" }, { status: 400 });
  }
};

