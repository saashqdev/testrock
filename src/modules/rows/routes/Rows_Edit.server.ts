import { redirect } from "next/navigation";
import { MetaTagsDto } from "@/lib/dtos/seo/MetaTagsDto";
import { createMetrics } from "@/modules/metrics/services/server/MetricTracker";
import NotificationService from "@/modules/notifications/services/server/NotificationService";
import { EntitiesApi } from "@/utils/api/server/EntitiesApi";
import { RowsApi } from "@/utils/api/server/RowsApi";
import UrlUtils from "@/utils/app/UrlUtils";
import { EntityWithDetailsDto } from "@/db/models/entityBuilder/EntitiesModel";
import { getUser } from "@/modules/accounts/services/UserService";
import EntityHelper from "@/lib/helpers/EntityHelper";
import { getEntityPermission } from "@/lib/helpers/PermissionsHelper";
import { verifyUserHasPermission } from "@/lib/helpers/server/PermissionsService";
import RowHelper from "@/lib/helpers/RowHelper";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import FormulaService from "@/modules/formulas/services/server/FormulaService";
import EventsService from "@/modules/events/services/.server/EventsService";
import { RowDeletedDto } from "@/modules/events/dtos/RowDeletedDto";
import ApiHelper from "@/lib/helpers/ApiHelper";
import { RowUpdatedDto } from "@/modules/events/dtos/RowUpdatedDto";
import { IServerComponentsProps } from "@/lib/dtos/ServerComponentsProps";
import { AdminUser } from "@prisma/client";
import { db } from "@/db";

export namespace Rows_Edit {
  export type LoaderData = {
    meta: MetaTagsDto;
    rowData: RowsApi.GetRowData;
    routes: EntitiesApi.Routes;
    allEntities: EntityWithDetailsDto[];
    relationshipRows: RowsApi.GetRelationshipRowsData;
  };
  export const loader = async (props: IServerComponentsProps): Promise<LoaderData> => {
    const params = (await props.params) || {};
    const request = props.request!;
    const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_Edit] ${params?.entity}`);
    const { t, userId, tenantId, entity } = await RowsRequestUtils.getLoader(props);
    const user = (await time(getUser(userId), "getUser")) as { admin?: AdminUser } | null;
    await time(verifyUserHasPermission(getEntityPermission(entity, "update"), tenantId), "verifyUserHasPermission");
    if (!entity.isAutogenerated || entity.type === "system") {
      throw redirect(tenantId ? UrlUtils.currentTenantUrl(params ?? {}, "404") : "/404?entity=" + params?.entity);
    }
    const rowData = await time(
      RowsApi.get(params?.id!, {
        entity,
        tenantId,
        userId,
      }),
      "RowsApi.get"
    );
    if (!rowData.rowPermissions.canUpdate && !user?.admin) {
      throw Error(t("shared.unauthorized"));
    }
    const data: LoaderData = {
      meta: [
        {
          title: `${t("shared.edit")} | ${RowHelper.getTextDescription({ entity, item: rowData.item, t })} | ${t(entity.titlePlural)} | ${
            process.env.APP_NAME
          }`,
        },
      ],
      rowData,
      routes: EntitiesApi.getNoCodeRoutes({ request, params }),
      allEntities: await time(db.entities.getAllEntities(tenantId), "getAllEntities"),
      relationshipRows: await time(RowsApi.getRelationshipRows({ entity, tenantId, userId }), "RowsApi.getRelationshipRows"),
    };
    return data;
  };

  export const action = async (formData: FormData, props?: IServerComponentsProps) => {
    "use server";

    // Create a proper request object for compatibility with existing utilities
    const request = new Request("http://localhost", {
      method: "POST",
    });

    // Mock the formData method on the request
    Object.defineProperty(request, "formData", {
      value: async () => formData,
      writable: false,
    });

    // Extract params from formData
    const entitySlug = formData.get("entity")?.toString() || "";
    const id = formData.get("id")?.toString() || "";
    const extractedParams = { entity: entitySlug, id };
    
    // Get original params for tenant/group info if available
    const originalParams = props ? await props.params : {};
    const fullParams = { ...originalParams, ...extractedParams };

    const { time, getServerTimingHeader } = await createMetrics({ request, params: extractedParams }, `[Rows_Edit] ${extractedParams.entity}`);
    const { t, userId, tenantId, entity } = await RowsRequestUtils.getAction({ request, params: Promise.resolve(extractedParams) });
    const form = formData;
    const user = await getUser(userId);
    const { item } = await time(
      RowsApi.get(extractedParams.id!, {
        entity,
        tenantId,
        userId,
      }),
      "RowsApi.get"
    );
    const action = form.get("action");
    let rowValues: any = {};
    if (action === "edit") {
      try {
        rowValues = RowHelper.getRowPropertiesFromForm({ t, entity, form, existing: item });
        const updatedRow = await time(
          RowsApi.update(extractedParams.id!, {
            entity,
            tenantId,
            userId,
            rowValues,
          }),
          "RowsApi.update"
        );
        await time(
          FormulaService.trigger({ trigger: "AFTER_UPDATED", rows: [updatedRow], entity: entity, session: { tenantId, userId }, t }),
          "FormulaService.trigger.AFTER_UPDATED"
        );
      } catch (error: any) {
        throw new Error(error.message);
      }
      const updatedRow = await RowsApi.get(extractedParams.id!, { entity });
      if (item.createdByUser) {
        // eslint-disable-next-line no-console
        console.log("Sending notification");
        await NotificationService.send({
          channel: "my-rows",
          to: item.createdByUser,
          notification: {
            from: { user },
            message: `${user?.email} updated ${RowHelper.getTextDescription({ entity, item })}`,
            action: {
              title: t("shared.view"),
              url: EntityHelper.getRoutes({ 
                routes: EntitiesApi.getNoCodeRoutes({ 
                  request, 
                  params: { 
                    tenant: (fullParams as any).tenant, 
                    group: (fullParams as any).group 
                  } 
                }), 
                entity, 
                item 
              })?.overview ?? "",
            },
          },
        });
        await EventsService.create({
          request,
          event: "row.updated",
          tenantId,
          userId,
          data: {
            id: item.id,
            title: RowHelper.getTextDescription({ entity, item, t }),
            entity: { id: entity.id, name: entity.name, slug: entity.slug, title: t(entity.title) },
            row: RowHelper.getDiff({ entity, before: item, after: updatedRow.item }),
            user: { id: user?.id ?? "", email: user?.email ?? "" },
          } satisfies RowUpdatedDto,
        });
      }
      const redirectTo = form.get("redirect")?.toString();
      if (redirectTo) {
        redirect(redirectTo);
      }
      return { success: true, updatedRow };
    } else if (action === "delete") {
      try {
        await time(verifyUserHasPermission(getEntityPermission(entity, "delete"), tenantId), "verifyUserHasPermission");
        await RowsApi.del(extractedParams.id!, {
          entity,
          userId,
          checkPermissions: !user?.admin,
        });
        await EventsService.create({
          request,
          event: "row.deleted",
          tenantId,
          userId,
          data: {
            id: item.id,
            title: RowHelper.getTextDescription({ entity, item, t }),
            row: ApiHelper.getApiFormat(entity, item),
            entity: { id: entity.id, name: entity.name, slug: entity.slug, title: t(entity.title) },
            user: { id: user?.id ?? "", email: user?.email ?? "" },
          } satisfies RowDeletedDto,
        });
      } catch (error: any) {
        throw new Error(error.message);
      }
      const redirectTo = form.get("redirect")?.toString();
      if (redirectTo) {
        redirect(redirectTo);
      }
      return { success: true, deleted: true };
    } else {
      throw new Error(t("shared.invalidForm"));
    }
  };
}
