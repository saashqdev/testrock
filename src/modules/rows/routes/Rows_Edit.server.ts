import { redirect } from "next/navigation";
import { MetaTagsDto } from "@/lib/dtos/seo/MetaTagsDto";
import { createMetrics } from "@/modules/metrics/services/server/MetricTracker";
import NotificationService from "@/modules/notifications/services/server/NotificationService";
import { Routes, getNoCodeRoutes } from "@/utils/api/server/EntitiesApi";
import { GetRowData, get, GetRelationshipRowsData, getRelationshipRows, update, del } from "@/utils/api/server/RowsApi";
import UrlUtils from "@/utils/app/UrlUtils";
import { EntityWithDetailsDto } from "@/db/models/entityBuilder/EntitiesModel";
import { getUser } from "@/modules/accounts/services/UserService";
import EntityHelper from "@/lib/helpers/EntityHelper";
import { getEntityPermission } from "@/lib/helpers/PermissionsHelper";
import { verifyUserHasPermission } from "@/lib/helpers/server/PermissionsService";
import RowHelper from "@/lib/helpers/RowHelper";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import FormulaService from "@/modules/formulas/services/server/FormulaService";
import EventsService from "@/modules/events/services/server/EventsService";
import { RowDeletedDto } from "@/modules/events/dtos/RowDeletedDto";
import ApiHelper from "@/lib/helpers/ApiHelper";
import { RowUpdatedDto } from "@/modules/events/dtos/RowUpdatedDto";
import { IServerComponentsProps } from "@/lib/dtos/ServerComponentsProps";
import { AdminUser } from "@prisma/client";
import { db } from "@/db";
import { headers } from "next/headers";

export type LoaderData = {
  meta: MetaTagsDto;
  rowData: GetRowData;
  routes: Routes;
  allEntities: EntityWithDetailsDto[];
  relationshipRows: GetRelationshipRowsData;
};
export const loader = async (props: IServerComponentsProps): Promise<LoaderData> => {
  const params = (await props.params) || {};
  const headersList = await headers();
  const request = new Request("http://localhost", {
    headers: headersList,
  });
  const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_Edit] ${params?.entity}`);
  const { t, userId, tenantId, entity } = await RowsRequestUtils.getLoader(props);
  const user = (await time(getUser(userId), "getUser")) as { admin?: AdminUser } | null;
  await time(verifyUserHasPermission(getEntityPermission(entity, "update"), tenantId), "verifyUserHasPermission");
  if (!entity.isAutogenerated || entity.type === "system") {
    throw redirect(tenantId ? UrlUtils.currentTenantUrl(params ?? {}, "404") : "/404?entity=" + params?.entity);
  }
  const rowData = await time(
    get(params?.id!, {
      entity,
      tenantId,
      userId,
    }),
    "get"
  );
  if (!rowData.rowPermissions.canUpdate && !user?.admin) {
    throw Error(t("shared.unauthorized"));
  }
  const data: LoaderData = {
    meta: [
      {
        title: `${t("shared.edit")} | ${RowHelper.getTextDescription({ entity, item: rowData.item, t })} | ${t(entity.titlePlural)} | ${
          process.env.APP_NAME
        }`,
      },
    ],
    rowData,
    routes: getNoCodeRoutes({ request, params }),
    allEntities: await time(db.entities.getAllEntities(tenantId, true), "getAllEntities"),
    relationshipRows: await time(getRelationshipRows({ entity, tenantId, userId }), "getRelationshipRows"),
  };
  return data;
};

export const action = async (formData: FormData, props?: IServerComponentsProps) => {
  "use server";

  // Create a proper request object for compatibility with existing utilities
  const request = new Request("http://localhost", {
    method: "POST",
  });

  // Mock the formData method on the request
  Object.defineProperty(request, "formData", {
    value: async () => formData,
    writable: false,
  });

  // Extract params from formData
  const entitySlug = formData.get("entity")?.toString() || "";
  const id = formData.get("id")?.toString() || "";
  const extractedParams = { entity: entitySlug, id };
  
  // Get original params for tenant/group info if available
  const originalParams = props ? await props.params : {};
  const fullParams = { ...originalParams, ...extractedParams };

  const { time, getServerTimingHeader } = await createMetrics({ request, params: extractedParams }, `[Rows_Edit] ${extractedParams.entity}`);
  const { t, userId, tenantId, entity } = await RowsRequestUtils.getAction({ request, params: Promise.resolve(extractedParams) });
  const form = formData;
  const user = await getUser(userId);
  const { item } = await time(
    get(extractedParams.id!, {
      entity,
      tenantId,
      userId,
    }),
    "get"
  );
  const action = form.get("action");
  let rowValues: any = {};
  if (action === "edit") {
    try {
      rowValues = RowHelper.getRowPropertiesFromForm({ t, entity, form, existing: item });
      const updatedRow = await time(
        update(extractedParams.id!, {
          entity,
          tenantId,
          userId,
          rowValues,
        }),
        "update"
      );
      await time(
        FormulaService.trigger({ trigger: "AFTER_UPDATED", rows: [updatedRow], entity: entity, session: { tenantId, userId }, t }),
        "FormulaService.trigger.AFTER_UPDATED"
      );
    } catch (error: any) {
      throw new Error(error.message);
    }
    const updatedRow = await get(extractedParams.id!, { entity });
    if (item.createdByUser) {
      // eslint-disable-next-line no-console
      console.log("Sending notification");
      await NotificationService.send({
        channel: "my-rows",
        to: item.createdByUser,
        notification: {
          from: { user },
          message: `${user?.email} updated ${RowHelper.getTextDescription({ entity, item })}`,
          action: {
            title: t("shared.view"),
            url: EntityHelper.getRoutes({ 
              routes: getNoCodeRoutes({ 
                request, 
                params: { 
                  tenant: (fullParams as any).tenant, 
                  group: (fullParams as any).group 
                } 
              }), 
              entity, 
              item 
            })?.overview ?? "",
          },
        },
      });
      await EventsService.create({
        request,
        event: "row.updated",
        tenantId,
        userId,
        data: {
          id: item.id,
          title: RowHelper.getTextDescription({ entity, item, t }),
          entity: { id: entity.id, name: entity.name, slug: entity.slug, title: t(entity.title) },
          row: RowHelper.getDiff({ entity, before: item, after: updatedRow.item }),
          user: { id: user?.id ?? "", email: user?.email ?? "" },
        } satisfies RowUpdatedDto,
      });
    }
    const redirectTo = form.get("redirect")?.toString();
    if (redirectTo) {
      redirect(redirectTo);
    }
    return { success: true, updatedRow };
  } else if (action === "delete") {
    try {
      await time(verifyUserHasPermission(getEntityPermission(entity, "delete"), tenantId), "verifyUserHasPermission");
      await del(extractedParams.id!, {
        entity,
        userId,
        checkPermissions: !user?.admin,
      });
      await EventsService.create({
        request,
        event: "row.deleted",
        tenantId,
        userId,
        data: {
          id: item.id,
          title: RowHelper.getTextDescription({ entity, item, t }),
          row: ApiHelper.getApiFormat(entity, item),
          entity: { id: entity.id, name: entity.name, slug: entity.slug, title: t(entity.title) },
          user: { id: user?.id ?? "", email: user?.email ?? "" },
        } satisfies RowDeletedDto,
      });
    } catch (error: any) {
      throw new Error(error.message);
    }
    const redirectTo = form.get("redirect")?.toString();
    if (redirectTo) {
      redirect(redirectTo);
    }
    return { success: true, deleted: true };
  } else {
    throw new Error(t("shared.invalidForm"));
  }
};

