import { redirect } from "next/navigation";
import { Routes, getNoCodeRoutes } from "@/utils/api/server/EntitiesApi";
import { GetRowsData, getAll } from "@/utils/api/server/RowsApi";
import UrlUtils from "@/utils/app/UrlUtils";
import { getEntityPermission } from "@/lib/helpers/PermissionsHelper";
import { verifyUserHasPermission } from "@/lib/helpers/server/PermissionsService";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import { createMetrics } from "@/modules/metrics/services/server/MetricTracker";

export type LoaderData = {
  entitiesData: { rowsData: GetRowsData }[];
  routes: Routes;
};
import { IServerComponentsProps } from "@/lib/dtos/ServerComponentsProps";
import { headers } from "next/headers";

export const loader = async (props: IServerComponentsProps) => {
  const params = (await props.params) || {};
  const headersList = await headers();
  const url = headersList.get("x-url") || headersList.get("referer") || "http://localhost";
  const request = new Request(url, {
    headers: headersList,
  });
  const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_Relationships] ${params.entity}`);
  const { userId, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params: props.params });
  await time(verifyUserHasPermission(getEntityPermission(entity, "view"), tenantId), "verifyUserHasPermission");
  if (!entity.isAutogenerated || entity.type === "system") {
    throw redirect(tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404");
  }

  const entitiesData: {
    rowsData: GetRowsData;
  }[] = [];

  async function getRowsData(entity: { id?: string; name?: string }) {
    return await getAll({
      entity,
      tenantId,
      userId,
      urlSearchParams: new URL(request.url).searchParams,
    });
  }
  await time(
    Promise.all(
      entity.parentEntities.map(async (relationship) => {
        entitiesData.push({
          rowsData: await getRowsData({ name: relationship.parent.name }),
        });
      })
    ),
    "parentEntities.getRowsData"
  );
  entitiesData.push({
    rowsData: await time(getRowsData({ name: entity.name }), "getRowsData"),
  });
  await time(
    Promise.all(
      entity.childEntities.map(async (relationship) => {
        entitiesData.push({
          rowsData: await getRowsData({ name: relationship.child.name }),
        });
      })
    ),
    "childEntities.getRowsData"
  );

  const data: LoaderData = {
    entitiesData: entitiesData.sort((a, b) => (a.rowsData.entity.order > b.rowsData.entity.order ? 1 : -1)),
    routes: getNoCodeRoutes({ request, params }),
  };
  return Response.json(data, { headers: getServerTimingHeader() });
};
