import { IEntitiesDb } from "@/db/interfaces/entityBuilder/IEntitiesDb";
import EntityModelHelper from "@/lib/helpers/models/EntityModelHelper";
import EntityViewModelHelper from "@/lib/helpers/models/EntityViewModelHelper";
import * as Constants from "@/lib/constants";
import { Prisma, Entity } from "@prisma/client";
import { db } from "@/db";
import { prisma } from "@/db/config/prisma/database";
import {
  EntityWithCountDto,
  EntityWithDetailsDto,
  EntityDto,
  EntityWithDetailsAndRelationshipsDto,
  RowsUsageDto,
} from "@/db/models/entityBuilder/EntitiesModel";
import EntitiesSingleton from "@/modules/rows/repositories/EntitiesSingleton";
import { DefaultLogActions } from "@/lib/dtos/shared/DefaultLogActions";
import { DefaultVisibility } from "@/lib/dtos/shared/DefaultVisibility";
import { defaultProperties } from "@/lib/helpers/PropertyHelper";
import { CreatePropertyDto } from "@/db/models/entityBuilder/PropertiesModel";
import { cachified } from "@/lib/services/cache.server";

export class EntitiesDbPrisma implements IEntitiesDb {
  async getEntitiesInIds(ids: string[]): Promise<EntityWithDetailsDto[]> {
    return await prisma.entity.findMany({
      where: { id: { in: ids } },
      include: {
        views: { include: { properties: true, filters: true, sort: true, groupByProperty: true } },
        tags: true,
        parentEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        childEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        properties: {
          orderBy: { order: "asc" },
          include: {
            attributes: true,
            options: {
              orderBy: {
                order: "asc",
              },
            },
            formula: { select: { name: true, resultAs: true, calculationTrigger: true } },
          },
        },
        templates: true,
      },
    });
  }

  async getAllEntities(tenantId: string | null, includeSystem?: boolean): Promise<EntityWithDetailsDto[]> {
    const cacheKey = `entities:all:${tenantId}:${includeSystem}`;
    
    // TEMPORARY: Disable caching to avoid memory issues during dev
    // Cache for 30 minutes in production
    const allEntities = await cachified({
      key: cacheKey,
      ttl: process.env.NODE_ENV === "production" ? 1000 * 60 * 30 : 1000 * 10, // 30min prod / 10sec dev
      disabled: process.env.NODE_ENV === "development", // Disable in dev to save memory
      getFreshValue: async () => {
        let where: Prisma.EntityWhereInput = {};
        // Optionally filter out system entities if includeSystem is false
        if (includeSystem === false) {
          where = { ...where, isAutogenerated: false };
        }
        return await prisma.entity.findMany({
          where,
          orderBy: [
            { type: "asc" },
            {
              order: "asc",
            },
          ],
          include: {
            views: { include: { properties: true, filters: true, sort: true, groupByProperty: true } },
            tags: true,
            parentEntities: {
              include: {
                parent: { select: EntityModelHelper.selectEntityWithoutIcon },
                child: { select: EntityModelHelper.selectEntityWithoutIcon },
                childEntityView: { include: EntityViewModelHelper.includeDetails },
                parentEntityView: { include: EntityViewModelHelper.includeDetails },
              },
              orderBy: { order: "asc" },
            },
            childEntities: {
              include: {
                parent: { select: EntityModelHelper.selectEntityWithoutIcon },
                child: { select: EntityModelHelper.selectEntityWithoutIcon },
                childEntityView: { include: EntityViewModelHelper.includeDetails },
                parentEntityView: { include: EntityViewModelHelper.includeDetails },
              },
              orderBy: { order: "asc" },
            },
            properties: {
              where: { ...(await this.filterTenantId(tenantId)) },
              orderBy: { order: "asc" },
              include: {
                attributes: true,
                options: {
                  orderBy: {
                    order: "asc",
                  },
                },
                formula: { select: { name: true, resultAs: true, calculationTrigger: true } },
              },
            },
            templates: {
              where: { ...(await this.filterTenantId(tenantId)) },
            },
          },
        });
      },
    });
    
    EntitiesSingleton.getInstance().setEntities(allEntities);
    return allEntities;
  }

  async getAllEntitiesSimple({ active, types }: { active?: boolean; types?: string[] } = {}): Promise<EntityDto[]> {
    let where: Prisma.EntityWhereInput = {};
    if (active) {
      where = { active };
    }
    if (types) {
      where = { ...where, type: { in: types } };
    }
    return await prisma.entity.findMany({
      where,
      orderBy: [
        { type: "asc" },
        {
          order: "asc",
        },
      ],
      select: EntityModelHelper.selectSimpleProperties,
    });
  }

  async getEntityDto({ id, name }: { id?: string; name?: string }): Promise<EntityDto | null> {
    if (!id && !name) {
      return null;
    } else if (id) {
      return await prisma.entity.findUnique({
        where: {
          id,
        },
        select: EntityModelHelper.selectSimpleProperties,
      });
    } else {
      return await prisma.entity.findUnique({
        where: {
          name,
        },
        select: EntityModelHelper.selectSimpleProperties,
      });
    }
  }

  async getEntitiesByName(name: string[]) {
    return await prisma.entity.findMany({
      where: {
        name: {
          in: name,
        },
      },
    });
  }

  async getAllEntitiesWithRowCount({ tenantId }: { tenantId: string | null }): Promise<EntityWithCountDto[]> {
    return await prisma.entity.findMany({
      include: {
        views: { include: { properties: true, filters: true, sort: true, groupByProperty: true } },
        tags: true,
        parentEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        childEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        templates: {
          where: { ...(await this.filterTenantId(tenantId)) },
        },
        _count: {
          select: {
            rows: true,
          },
        },
        properties: {
          where: { ...(await this.filterTenantId(tenantId)) },
          orderBy: { order: "asc" },
          include: {
            attributes: true,
            options: {
              orderBy: {
                order: "asc",
              },
            },
            formula: { select: { name: true, resultAs: true, calculationTrigger: true } },
          },
        },
      },
      orderBy: [
        { type: "asc" },
        {
          order: "asc",
        },
      ],
    });
  }

  async getAllRowsUsage(tenantId: string): Promise<RowsUsageDto[]> {
    const countEntities = await prisma.row.groupBy({
      by: ["entityId"],
      _count: true,
      where: {
        OR: [
          {
            tenantId,
          },
        ],
      },
    });
    return countEntities;
  }

  // async getRowsCount(tenantId: string, entityId: string): Promise<number> {
  //   const whereTenant = {
  //     OR: [
  //       {
  //         tenantId,
  //       },
  //     ],
  //   };
  //   if (!entityLimit || entityLimit.type === EntityLimitType.MAX) {
  //     return await prisma.row.count({
  //       where: {
  //         entityId,
  //         ...whereTenant,
  //       },
  //     });
  //   } else {
  //     return await prisma.row.count({
  //       where: {
  //         entityId: entityLimit.entityId,
  //         ...whereTenant,
  //         // TODO: CURRENT MONTH
  //       },
  //     });
  //   }
  // }

  async getEntityById({ id, tenantId }: { id: string; tenantId: string | null | undefined }): Promise<EntityWithDetailsAndRelationshipsDto | null> {
    return await prisma.entity.findUnique({
      where: {
        id,
      },
      include: {
        views: { include: { properties: true, filters: true, sort: true, groupByProperty: true } },
        tags: true,
        parentEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        childEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        properties: {
          where: { ...(await this.filterTenantId(tenantId)) },
          orderBy: { order: "asc" },
          include: {
            attributes: true,
            options: {
              orderBy: {
                order: "asc",
              },
            },
            formula: { select: { name: true, resultAs: true, calculationTrigger: true } },
          },
        },
        templates: {
          where: { ...(await this.filterTenantId(tenantId)) },
        },
      },
    });
  }

  async getEntityBySlug({ tenantId, slug, activeOnly }: { tenantId: string | null; slug: string; activeOnly?: boolean }): Promise<EntityWithDetailsDto> {
    const entity = await prisma.entity.findUnique({
      where: {
        slug,
      },
      include: {
        views: { include: { properties: true, filters: true, sort: true, groupByProperty: true } },
        tags: true,
        parentEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        childEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        properties: {
          where: { ...(await this.filterTenantId(tenantId)) },
          orderBy: { order: "asc" },
          include: {
            attributes: true,
            // entity: {
            //   include: {
            //     ...includePropertiesWithDetails,
            //   },
            // },
            options: {
              orderBy: {
                order: "asc",
              },
            },
            formula: { select: { name: true, resultAs: true, calculationTrigger: true } },
          },
        },
        templates: {
          where: { ...(await this.filterTenantId(tenantId)) },
        },
      },
    });
    if (!entity) {
      throw new Error(`Entity '${slug}' not found`);
    }
    if (activeOnly && !entity.active) {
      throw new Error(`Entity '${slug}' is not active`);
    }
    return entity;
  }

  async getSimpleEntityBySlug(slug: string): Promise<EntityDto | null> {
    return await prisma.entity.findUnique({
      where: {
        slug,
      },
      select: EntityModelHelper.selectSimpleProperties,
    });
  }

  async findEntityBySlug(slug: string): Promise<Entity | null> {
    return await prisma.entity.findUnique({
      where: { slug },
    });
  }

  async getEntityByName({ tenantId, name }: { tenantId: string | null | undefined; name: string }): Promise<EntityWithDetailsDto> {
    const entity = await prisma.entity.findUnique({
      where: {
        name,
      },
      include: {
        views: { include: { properties: true, filters: true, sort: true, groupByProperty: true } },
        tags: true,
        parentEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        childEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        properties: {
          where: { ...(await this.filterTenantId(tenantId)) },
          orderBy: { order: "asc" },
          include: {
            // entity: {
            //   include: {
            //     ...includePropertiesWithDetails,
            //   },
            // },
            attributes: true,
            options: {
              orderBy: {
                order: "asc",
              },
            },
            formula: { select: { name: true, resultAs: true, calculationTrigger: true } },
          },
        },
        templates: {
          where: { ...(await this.filterTenantId(tenantId)) },
        },
      },
    });
    if (!entity) {
      throw new Error(`Entity with name ${name} not found`);
    }
    return entity;
  }

  async getEntityByIdOrName({ tenantId, id, name }: { tenantId: string | null | undefined; id?: string; name?: string }): Promise<EntityWithDetailsDto> {
    let entity: EntityWithDetailsDto | null = null;
    if (id) {
      entity = await this.getEntityById({ tenantId, id });
    } else if (name) {
      entity = await this.getEntityByName({ tenantId, name });
    }
    if (!entity) {
      throw new Error(`Entity with id ${id} or name ${name} not found`);
    }
    return entity;
  }

  async getEntityByIdNameOrSlug({ tenantId, idNameOrSlug }: { tenantId: string | null; idNameOrSlug: string }): Promise<EntityWithDetailsDto> {
    return await this.getEntityWithWhere({
      tenantId,
      where: {
        OR: [{ id: idNameOrSlug }, { name: idNameOrSlug }, { slug: idNameOrSlug }],
      },
    });
  }

  async getEntityWithWhere({ tenantId, where }: { tenantId: string | null; where: Prisma.EntityWhereInput }) {
    const entity = await prisma.entity.findFirst({
      where,
      include: {
        views: { include: { properties: true, filters: true, sort: true, groupByProperty: true } },
        tags: true,
        parentEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        childEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        properties: {
          where: { ...(await this.filterTenantId(tenantId)) },
          orderBy: { order: "asc" },
          include: {
            // entity: {
            //   include: {
            //     ...includePropertiesWithDetails,
            //   },
            // },
            attributes: true,
            options: {
              orderBy: {
                order: "asc",
              },
            },
            formula: { select: { name: true, resultAs: true, calculationTrigger: true } },
          },
        },
        templates: {
          where: { ...(await this.filterTenantId(tenantId)) },
        },
      },
    });
    if (!entity) {
      throw new Error(`Entity not found`);
    }
    return entity;
  }

  async findEntityByName({ tenantId, name }: { tenantId: string | null; name: string }): Promise<EntityWithDetailsDto | null> {
    return await prisma.entity.findUnique({
      where: { name },
      include: {
        views: { include: { properties: true, filters: true, sort: true, groupByProperty: true } },
        tags: true,
        parentEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        childEntities: {
          include: {
            parent: { select: EntityModelHelper.selectEntityWithoutIcon },
            child: { select: EntityModelHelper.selectEntityWithoutIcon },
            childEntityView: { include: EntityViewModelHelper.includeDetails },
            parentEntityView: { include: EntityViewModelHelper.includeDetails },
          },
          orderBy: { order: "asc" },
        },
        properties: {
          where: { ...(await this.filterTenantId(tenantId)) },
          orderBy: { order: "asc" },
          include: {
            // entity: {
            //   include: {
            //     ...includePropertiesWithDetails,
            //   },
            // },
            attributes: true,
            options: {
              orderBy: {
                order: "asc",
              },
            },
            formula: { select: { name: true, resultAs: true, calculationTrigger: true } },
          },
        },
        templates: {
          where: { ...(await this.filterTenantId(tenantId)) },
        },
      },
    });
  }

  async findSimpleEntityByName(name: string): Promise<{ id: string; title: string; titlePlural: string; slug: string } | null> {
    if (EntitiesSingleton.getInstance().isSet()) {
      return (
        EntitiesSingleton.getInstance()
          .getEntities()
          .find((f) => f.name === name) ?? null
      );
    }
    return await prisma.entity.findUnique({
      where: { name },
      select: { id: true, title: true, titlePlural: true, slug: true },
    });
  }

  async getEntityByPrefix(prefix: string): Promise<Entity | null> {
    return await prisma.entity.findUnique({
      where: {
        prefix,
      },
    });
  }

  async createEntity(
    data: {
      name: string;
      slug: string;
      prefix: string;
      title: string;
      titlePlural: string;
      isAutogenerated: boolean;
      type: string;
      hasApi: boolean;
      icon: string;
      active: boolean;
      showInSidebar: boolean;
      hasTags: boolean;
      hasComments: boolean;
      hasTasks: boolean;
      hasActivity: boolean;
      hasBulkDelete: boolean;
      hasViews: boolean;
      defaultVisibility: string;
      onCreated: string | null;
      onEdit: string | null;
    },
    order?: number | null
  ) {
    if (!order) {
      order = (await this.getMaxEntityOrder()) + 1;
    }
    const entity = await prisma.entity.create({
      data: {
        ...data,
        order,
      },
    });

    const webhooks = [
      {
        action: DefaultLogActions.Created,
        method: "POST",
        endpoint: "",
      },
      {
        action: DefaultLogActions.Updated,
        method: "POST",
        endpoint: "",
      },
      {
        action: DefaultLogActions.Created,
        method: "POST",
        endpoint: "",
      },
    ];

    await Promise.all(
      webhooks.map(async (webhook) => {
        return await prisma.entityWebhook.create({
          data: {
            entityId: entity.id,
            action: webhook.action,
            method: webhook.method,
            endpoint: webhook.endpoint,
          },
        });
      })
    );

    await Promise.all(
      defaultProperties.map(async (property) => {
        return await prisma.property.create({
          data: {
            entityId: entity.id,
            ...property,
          },
        });
      })
    );

    return entity;
  }

  async createCoreEntity(
    data: {
      name: string;
      slug: string;
      title: string;
      titlePlural: string;
      prefix: string;
      type: string;
      isAutogenerated?: boolean;
      hasApi?: boolean;
      icon?: string;
      active?: boolean;
      showInSidebar?: boolean;
      hasTags?: boolean;
      hasComments?: boolean;
      hasTasks?: boolean;
      hasActivity?: boolean;
      hasBulkDelete?: boolean;
      hasViews?: boolean;
      defaultVisibility?: DefaultVisibility;
      onCreated?: string | null;
      onEdit?: string | null;
    },
    properties?: CreatePropertyDto[]
  ) {
    const entity = await this.createEntity({
      name: data.name,
      slug: data.slug,
      prefix: data.prefix,
      title: data.title,
      titlePlural: data.titlePlural,
      type: data.type,
      isAutogenerated: data.isAutogenerated !== undefined ? data.isAutogenerated : true,
      hasApi: data.hasApi !== undefined ? data.hasApi : true,
      icon: data.icon !== undefined ? data.icon : "",
      active: data.active !== undefined ? data.active : true,
      showInSidebar: data.showInSidebar !== undefined ? data.showInSidebar : true,
      hasTags: data.hasTags !== undefined ? data.hasTags : true,
      hasComments: data.hasComments !== undefined ? data.hasComments : true,
      hasTasks: data.hasTasks !== undefined ? data.hasTasks : false,
      hasActivity: data.hasActivity !== undefined ? data.hasActivity : true,
      hasBulkDelete: data.hasBulkDelete !== undefined ? data.hasBulkDelete : false,
      hasViews: data.hasViews !== undefined ? data.hasViews : true,
      defaultVisibility: data.defaultVisibility ?? Constants.DEFAULT_ROW_VISIBILITY,
      onCreated: data.onCreated ?? "redirectToOverview",
      onEdit: data.onEdit ?? "editRoute",
    });
    if (properties) {
      await db.properties.createProperties(entity.id, properties);
    }
    return entity;
  }

  async updateEntity(data: {
    id: string;
    name?: string;
    slug?: string;
    displayName?: string;
    description?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
    order?: number;
    prefix?: string;
    title?: string;
    titlePlural?: string;
    isAutogenerated?: boolean;
    type?: string;
    hasApi?: boolean;
    active?: boolean;
    showInSidebar?: boolean;
    hasTags?: boolean;
    hasComments?: boolean;
    hasTasks?: boolean;
    hasActivity?: boolean;
    hasBulkDelete?: boolean;
    hasViews?: boolean;
    defaultVisibility?: DefaultVisibility | string;
    onCreated?: string | null;
    onEdit?: string | null;
    updatedById?: string;
  }) {
    const { id, ...updateData } = data;

    return await prisma.entity.update({
      where: {
        id,
      },
      data: updateData,
    });
  }

  async deleteEntity(id: string, tenantId: string | null) {
    return await prisma.entity.delete({
      where: {
        id,
      },
    });
  }

  async getMaxEntityOrder(): Promise<number> {
    return (
      (
        await prisma.entity.aggregate({
          _max: {
            order: true,
          },
        })
      )._max?.order ?? 0
    );
  }

  async getDefaultEntityVisibility(id: string): Promise<DefaultVisibility> {
    return ((
      await prisma.entity.findUnique({
        where: { id },
        select: {
          defaultVisibility: true,
        },
      })
    )?.defaultVisibility ?? Constants.DEFAULT_ROW_VISIBILITY) as DefaultVisibility;
  }

  async filterTenantId(tenantId: string | null | undefined) {
    const filter: { tenantId?: string | null; OR?: { tenantId?: string | null }[] } = {};
    if (tenantId === undefined) {
      return filter;
    } else if (tenantId === null) {
      filter.tenantId = null;
    } else {
      filter.OR = [{ tenantId: null }, { tenantId }];
    }
    return filter;
  }
}
